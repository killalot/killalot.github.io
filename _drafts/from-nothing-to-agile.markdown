---
layout: post
title: "From Nothing to Agile"
excerpt: "One programmer's 3 year journey into making an agile team."
keywords: "Agile, Continuous Integration, TDD, Jenkins, Code Review"
---

## My Story
This is an account of how I turned our small collection of programmers into a modern agile development team. What follows is a series of progressive improvements that I have introduced over a period of 3 years. Now every team is different and so don't think of this as a step by step guide to becoming agile. Think of it as an example from which you can draw from and merge with your own experience to help your team become more agile no matter how far into the journey you are.

## Almost Nothing

So a bit of background to set the scene.

To keep track of file changes to our code base we used CVS for version control. Our central CVS server was a slow archaic machine kept underneath the senior programmers desk.

No unit, integration tests, functional tests. CVS - slow archaic server. One developers responsibility to manually merge in changes. Manual testing only, not a lot of it. No policies about code quality or convention

## Git and Github

When I joined the team we were using CVS as our means to keep track of file changes. Our CVS server was a slow and archaic machine, which was probably the first machine CVS was installed onto.

At the time I wasn't particularly aware of the bad points of CVS. I certainly found merging code from the central server a chore but since I had no experience of SCM I was none the wiser. After few months of me being part of the team I came across Git. I don't remember exactly how I became aware of git but I do remember watching this [amazing talk by Linus Torvalds](https://youtu.be/4XpnKHJAok8). This was basically an eye opener for me as far as how you should do SCM.

Very soon after learning about Git (maybe even at the same time) I heard about GitHub as I way to store git repository in the cloud. Though this wasn't the main reason I was interested in it. What caught my eye was that you can store and maintain issues associated with the repository. This was a great plus point because at the time we didn't keep a record of current issues in an accessible place. The system we had in place was basically someone tells you about the problem, usually by coming over to your desk, and then you right it down on a piece of paper (if you remember to) and off you go. Using that system there is no historic record of what was discussed, the programmer just has to make a best guess that this is what they meant.

## Well we should be testing

## Manual testing is boring

## Scrum, sprint and points

## Gitflow workflow

##

## Bump up the Quality

## Understandable Commit Messages

## I Will Review Your Code

## Kanban board

## Never-ending Story
The foresight to reflect
